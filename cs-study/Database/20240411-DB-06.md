# 20240411 6차 DB 스터디

질문자 : 최은혜

답변자 : 이강현, 오유진, 최다환

범위 : [데이터베이스 개론 3판: 김연희 저] 
<br>
ch10 회복과 병행 제어, ch11 보안과 권한 관리

---

### Q1. 트랜잭션의 4가지 특징중 하나를 선택해 설명하세요.

유진: 저는 일관성에 대해 설명해드리도록 하겠습니다. 일관성은 트랜잭션이 수행하고 나서 데이터베이스의 값들이 일관성있게 유지되어야 합니다. 계좌이체를 예를 들어 설명드리자면, 철수가 10000원, 영희가 0원인 상황에서 철수 계좌에서 5000원을 빼고 장애가 발생하여 연산이 끝나버리면 원래는 둘이 합쳐서 10000원이었던 것이 5000원이 되어버렸기때문에 일관성이 없다고 할 수 있습니다. 

강현: 저는 지속성에 대해 설명드리겠습니다. 지속성이란 트랜잭션 연산이 모두 완료된 이후 데이터베이스에 반영한 결과는 열구적이어야한다는 특성입니다. 계좌이체로 예를 들자면, A가 10000원, B가 0원을 들고 있을때 A가 B에게 5000원을 보낸다면 각각 5000원을 들고 있을 것입니다. 지속성은 이렇게 각각 5000원을 가지고 있다는 것이 데이터베이스에 영구적으로 남아있다는 것을 의미합니다. 

다환: 저는 원자성에 대해 설명드리겠습니다. 원자성이란 트랜잭션 연산이 모두 수행되거나 아니면 모두 수행되지않아야하는 특성입니다. 예를 들어 계좌이체 상황에서, 트랜잭션 연산이 2가지가 있다고 가정해서 설명하겠습니다. 철수의 계좌 10000원중 5000원을 영희에게 입금하려고 할때, 철수의 계좌에서 5000원을 뺀 후 장애가 발생하고, 연산을 끝내버리면 연산후 철수의 계좌에는 5000원, 영희의 계좌에는 0원이 있으므로 원자성을 위배한 상황입니다. 

> Sol </br>
> **원자성**은 트랜잭션의 연산이 모두 정상적으로 수행되거나 하나도 수행되지 않아야 한다는 것을 의미합니다.</br>
**일관성**은 트랜잭션이 수행된 후에도 데이터베이스가 일관성 있는 상태여야 한다는 것을 의미합니다. </br>
**격리성**은 수행 중인 트랜잭션이 완료될 때까지 다른 트랜잭션들이 중간 연산 결과에 접근할 수 없는 것을 의미합니다.</br>
**지속성**은 트랜잭션의 수행이 완료된 후에 데이터베이스에 반영한 결과는 영구적이어야함을 의미합니다.
<br>
<br>
<br>

### Q2. 트랜잭션의 상태 5가지에 대해 설명하세요.

유진: 트랜잭션은 총 5가지의 상태로 구분되는데, 활동상태, 부분 완료 상태, 완료 상태, 실패 상태, 철회 상태가 있습니다. 트랜잭션이 수행 중인 상태를 활동 상태라고 하고, 트랜잭션 연산을 모두 수행한 상태를 부분 완료상태라고 합니다. 이 상태에서 commit이 완료되면 완료 상태가 됩니다. 그렇지만 트랜잭션이 실행되는 과정에서 중단이 되어서 실패되면 실패 상태라고 하며, 실패된 상태에서 트랜잭션을 rollback 한 상태를 철회 상태라고 합니다.

> Sol </br>
> **활동상태**는 트랜잭션이 수행을 시작하여 현재 수행 중인 상태입니다. </br>
**부분 완료 상태**는 트랜잭션의 마지막 연산이 실행을 끝낸 직후의 상태입니다. </br>
**완료상태**는 트랜잭션이 성공적으로 완료되어 commit연산을 실행한 상태입니다. </br>
**실패상태**는 장애가 발생하여 트랜잭션의 수행이 중단된 상태입니다. </br>
**철회상태**는 트랜잭션의 수행 실패로 rollback 연산을 실행한 상태입니다. </br>
<br>
<br>
<br>

### Q3. 메인 메모리의 버퍼 블록과 프로그램 변수간의 데이터 이동연산인 read와 write에 대해 설명하세요.

유진: input 값으로 디스크에 있는 데이터를 메인 메모리로 이동시키고, 메인 메모리에서 변수값을 읽어오는 과정을 read라고 합니다. 그리고 이런 변수의 반환값을 메인 메모리에 기록하는 과정을 write라고 하며, 기록한 것을 디스크에 옮기는 것을 output이라고 합니다. 

강현: 메인 메모리의 버퍼 블록에서 응용 프로그램의 변수를 읽어 오는 것을 read라고 하며, 응용 프로그램에서 연산을 한 뒤에 변수를 메인 메모리의 버퍼 블록으로 넘겨주는 것을 write라고 합니다.   

다환: 메인 메모리에 있는 것을 버퍼 블록이라고 하고, 디스크에 있는 블록을 디스크 블록이라고 하는데요. 이 블록은 메모리간의 연산에 수행되는 범위를 의미합니다. 이때 read와 write는 응용프로그램이랑 메모리 블록사이에서 일어나는 연산을 말합니다. read는 버퍼 블록에 있는 변수를 가져오는 것을 의미하고, write 연산은 응용 프로그램 변수에 있는 것을 버퍼 블록에 있는 데이터에 넣는 것을 말하는데,read와 write 연산은 대부분 input과 output연산을 동반합니다. input연산은 버퍼블록에다가 디스크블록에 있는 데이터를 가져오는것이고, output은 버퍼블록에 있는 것은 디스크블록으로 넣는 것을 의미합니다. 

> Sol: read(x)는 메인메모리 버퍼 블록에 젖아되어 있는 데이터 x를 프로그램의 변수로 읽어오는 연산이고, write(x)는 프로그램의 변수 값을 메인 메모리 버퍼 블록에 있는 데이터 x에 기록하는 연산입니다. 
<br>
<br>
<br>

### Q4-1). 장애 발생 시 회복 기법 중 로그 기법에 대해 설명하세요.
다환: 로그 회복기법에는 즉시 갱신 회복기법과 지연 갱신 회복기법이 있습니다. </br>
즉시 갱신 회복기법은 트랜잭션의 연산이 일어날때마다 그때그때 데이터베이스에 반영하고 로그파일에 기록을 하는 방법으로, 만약 트랜잭션에 장애가 생긴다면 그 시점에 따라 undo연산을 할지 redo연산을 할지 결정합니다. 트랜잭션이 전부 실행이 되고 commit이 끝났을 때 장애가 발생하는 경우 redo 연산을 실행하고, 트랜잭션을 실행하는 도중에 장애가 발생하면 undo 연산을 실행합니다.</br>
그리고 지연 갱신 회복기법은 트랜잭션의 연산이 일어날때마다 즉각적으로 반영하는 것이 아니라 우선 로그 파일에만 저장한 다음에 commit 연산이 되었을 때 데이터베이스에 기록하는 것을 의미합니다. 만약 트랜잭션이 commit이 완료되었을 때는 redo 연산을 수행하지만, 트랜잭션 수행 도중 장애가 발생한다면 로그 파일을 버리는 기법입니다. 

### Q4-2). 장애 발생 시 회복 기법 중 검사 회복 기법에 대해 설명하세요.
유진: 로그 회복기법의 단점은 맨 처음 트랜잭션이 시작하기 전부터 실행할때까지 과정들을 다 살펴보면서 어디서 장애가 발생했는지를 파악해야하는데, 검사 회복 기법의 장점은 특정 포인트를 설정해서 검사 시점으로부터만 트랜잭션 연산을 실행하면되기때문에 시간을 효율적으로 쓸 수 있습니다. 

### Q4-3). 장애 발생 시 회복 기법 중 미디어 회복 기법에 대해 설명하세요.
강현: 미디어 회복 기법에는 데이터 베이스 전체를 다른 저장장치에 저장해두는 덤프를 사용합니다. 데이터베이스 전체가 장애가 발생해서 데이터베이스를 통으로 바꿔야할 때 따로 저장해둔 전체 데이터베이스를 가져와서 회복하는 방법을 말합니다. 단점으로는 회복을 하는동안 CPU를 많이 사용하며 비용이 많이 든다는 단점이 있습니다. 

> Sol </br>
**로그 회복 기법** 은 데이터를 변경한 연산 결과를 데이터베이스에 반영하는시점에 따라 나뉩니다. 즉시 갱신 회복 기법은 트랜잭션 수행중에 데이터를 변경한 연산 결과를 데이터베이스에 즉시 반영하는 것이고, 지연 갱신 회복 기법은 트랜잭션이 수행되는 동안에는 데이터 변경 연산의 결과를 데이터베이스에 즉시 반영하지 않고 로그 파일에만 기록해두었다가 트랜잭션이 완료된 후에 기록된 내용을 이용하여 데이터베이스에 한번에 반영하는 것 입니다. </br>
**검사 시점 회복 기법**은 일정 시간 간격으로 검사 시점을 만들어두어서 불필요한 회복 작업을 수행하지 않는 기법입니다. </br>
**미디어 회복 기법**은 디스크에 발생할 수 있는 장애에 대비한 회복기법으로, 디스크 장애가 발생하면 가장 최근에 복사해둔 덤프를 이용해 장애 발생 이전의 일관된 데이터베이스 상태로 복구하는 기법입니다. 
<br>
<br>
<br>

### Q5-1). 병행제어 수행 시의 문제점 3가지 중 한 가지를 선택해 설명하세요.
강현: 저는 연쇄복귀에 대해 설명하겠습니다. 연쇄복귀란 트랜잭션 A와 B가 있다고 할 때, 트랜잭션 A를 수행하는 와중에 트랜잭션 B가 완성이 되고 그 이후에 A의 남은 연산을 수행하다가 장애가 발생해 다시 rollback 한다면 트랜잭션 B도 같이 rollback을 해야하는 문제점입니다. 

### Q5-2). 병행제어 수행 시의 문제점 3가지 중 한 가지를 선택해 설명하세요.
유진: 저는 모순성에 대해 설명하도록 하겠습니다. T1와 T2라는 트랜잭션이 있다고 가정하면 T1에서 x값이 변경되고 나서 T2 작업을 수행하고 T1의 y값을 변경한다면, x값과 y값의 시점이 다르기 때문에 모순성을 가지게 됩니다. 이렇게 되면 데이터의 일관성이 떨어질 수 있습니다. 

### Q5-3). 병행제어 수행 시의 문제점 3가지 중 한 가지를 선택해 설명하세요.
다환: 저는 갱신 분실에 대해 설명드리겠습니다. 갱신 분실이란 트랜잭션 1과 2가 동시에 x에 대한 연산을 시작했다고 가정하면, 트랜잭션 1이 x에 대한 연산이 끝나서 데이터베이스에 반영을 했는데 트랜잭션 2가 이미 이전 x값을 가지고 연산을 시작했기때문에, 트랜잭션 1이 x값을 갱신해도 트랜잭션 2도 x값을 다시 갱신함으로써 트랜잭션 1의 연산이 반영되지않음을 말합니다. 

> Sol </br>
**갱신 분실**은 하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화되는 것입니다.</br>
**모순성**은 하나의 트랜잭션이 여러개의 데이터 변경 연산을 실행할 때 일관성 없는 상태의 데이터베이스에서 데이터를 가져와 연산을 실행함으로써 모순된 결과가 발생하는 것입니다. </br>
**연쇄 복귀**는 트랜잭션이 완료되기 전에 장애가 발생하여 rollback 연산을 수행하면, 이 트랜잭션이 장애 발생 전에 변경한 데이터를 가져가 변경 연산을 실행한 또 다른 트랜잭션에도 rollback 연산을 연쇄적으로 실행해야 한다는 것입니다.
<br>
<br>
<br>

### Q6. 2단계 로킹 규약에 대해 설명하세요

유진: 2단계 로킹 규약의 필요성에 대해 먼저 말씀을 드리겠습니다. 직렬 가능성을 보장해야하기 때문에 2단계 로킹 규약이 필요합니다. 이를 2단계로 나눌수 있는데 확장 단계와 축소 단계가 있습니다. 확장 단계는 lock은 가능하지만 unlock은 불가능한 단계이고, 축소단계는 lock은 불가능하지만 unlock은 가능한 단계입니다.</br>
lock은 크게 공동 lock과 전용 lock이 있습니다. 공동 lock은 이 lock을 사용하게된다면 다른 사용자는 읽을 수 만있고 쓸 수 있는 권한은 가질 수 없습니다. 하지만 전용 lock을 사용하면, 독점성을 가지게 되어서 다른 사용자들이 읽거나 쓸 수 없게됩니다. 

강현: 2단계 로킹 규약은 직렬 가능성을 보장하기 위해 사용해야하는 규약입니다. 2단계 로킹 규약에는 확장 상태와 축소 상태가 있는데, 확장 상태는 lock 연산만 수행할 수 있는 상태이고 축소 상태는 unlock 연산만 수행할 수 있는 상태입니다.</br>
또한 lock은 공용 lock과 전용 lock으로 구분되는데, 공용 lock은 트랜잭션 A가 공용 lock을 특정 데이터에 걸었을 때 다른 트랜잭션들이 데이터를 읽을 수 만 있는 상태를 의미하고 다른 트랜잭션도 공용 lock을 해당 데이터에 동시에 걸 수 있습니다. 하지만 전용 lock은 한 트랜잭션이 그 데이터에 대한 독점권을 갖게 되어 다른 트랜잭션은 해당 데이터를 읽지도 못하는 것을 의미합니다.</br>
그리고 2단계 로킹 규약 사용시 교착상태가 일어날 수 있는데, 이때 교착상태란 서로 다른 두 트랜잭션이 lock을 걸어둔 데이터를 상대방이 unlock하기만을 계속 기다리는 상태입니다. 교착상태를 미리 예방하거나 발생시 최대한 빨리 조치하는 것이 필요합니다.

다환: 2단계 로킹 규약이란, 직렬 가능성을 보장하기 위해 사용하는 규약입니다. 먼저 트랜잭션이 활성화되어서 연산을 시작할때에는 확장 상태가 되고, unlock 연산을 실행했을 때에는 축소 상태에 들어갑니다. 이때 확장 상태일때에는 lock 연산만 수행할 수 있고, 축소상태일때에는 unlock 연산만 수행할 수 있습니다. 때문에 unlock 연산을 최초로 수행하기 전에 트랜잭션은 자신이 연산을 할 때 필요로 하는 모든 데이터에 lock연산을 걸어야합니다.
그런데 이럴때 교착상태가 일어날 수 있는데, 교착상태가 일어나기전에 미리 예방하거나 조치하는것이 필요합니다.

> Sol: 2단계 로킹규약은 트랜잭션의 직렬 가능성을 보장하기 위한 규약으로 확장단계와 축소단계가 있습니다. 확장단계는 트랜잭션이 lock 연산만 실행할 수 있지만 unlock연산은 실행할 수 없는 단계이고, 축소단계는 트랜잭션이 unlock 연산만 실행할 수 있지만 lock연산은 실행할 수 없는 단계입니다.
<br>
<br>
<br>


### Q7-1). 권한을 부여하고 취소하는 명령문 2가지를 말씀해보세요.
강현: 권한을 부여하는 것은 GRANT문이고, 취소하는 것은 REVOKE문입니다. 

### Q7-2). 역할을 생성하고 역할에 대한 권한을 추가하는 명령문 2가지를 말씀해보세요.
유진: 역할을 생성하는 것은 CREATE ROLE 문이고, 역할에 대한 권한을 추가하는 것은 GRANT문입니다. 

### Q7-3). 역할의 부여와 취소를 하는 명령문 2가지를 말씀해보세요.
다환: 역할을 부여할 때에는 GRANT문을 사용하고, 취소할때에는 REVOKE문을 사용합니다.
 
<br>
<br>
<br>

### Q8. 역할을 사용하게 되면 얻는 장점에 대해 설명하세요.

유진: 역할은 바구니 같은 개념으로, 다양한 연산들을 바구니에 담아서 더 빠르고 간편하게 부여할 수 있습니다. 

강현: 역할마다 권한을 설정해주고 그 역할을 사용자들에게만 주는 방식으로, 불필요한 단순 반복 작업을 줄이고 더욱더 편한게 권한에 대해 관리하고 회수할 수 있습니다. 

다환: 역할을 사용하지 않으면, 여러 GRANT문을 사용해서 여러개의 권한을 부여해야하지만, 역할을 사용하면 이런 복잡한 연산을 하지않고도 여러 권한을 여러 사용자에게 부여할 수 있습니다. 

> Sol: 역할을 사용하게되면 권한 부여와 수정작업이 편해지고, 여러 사용자에게 한번에 같은 권한 부여가 가능해집니다. 또한 권한에 대한 관리가 쉽단느 장점이 있습니다. 
<br>
<br>
<br>


